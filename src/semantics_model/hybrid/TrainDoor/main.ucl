/**************************************
 * An axiomatic and operational model *
 **************************************/
module main {
 
    /*******************************
     * Time and Related Operations *
     ******************************/
    type timestamp_t = integer; // Unit is nanoseconds
    type microstep_t = integer;
    type tag_t = {
        timestamp_t,
        microstep_t
    };
    // FIXME: in LF, the interval is an integer.
    type interval_t  = tag_t;
    
    // Projection macros
    define pi1(t : tag_t)   : timestamp_t   = t._1;         // Get timestamp from tag
    define pi2(t : tag_t)   : microstep_t   = t._2;         // Get microstep from tag
    
    // Interval constructor
    define zero() : interval_t
    = {0, 0};
    define startup() : interval_t
    = zero();
    define mstep() : interval_t
    = {0, 1};
    define nsec(t : integer) : interval_t
    = {t, 0};
    define usec(t : integer) : interval_t
    = {t * 1000, 0};
    define msec(t : integer) : interval_t
    = {t * 1000000, 0};
    define sec(t : integer) : interval_t
    = {t * 1000000000, 0};
    define inf() : interval_t
    = {-1, 0};
    
    // Helper function
    define isInf(i : interval_t) : boolean
    = pi1(i) < 0;
    
    // Tag comparison
    define tag_later(t1 : tag_t, t2 : tag_t) : boolean
    = pi1(t1) > pi1(t2)
        || (pi1(t1) == pi1(t2) && pi2(t1) > pi2(t2))
        || (isInf(t1) && !isInf(t2));
    
    define tag_same(t1 : tag_t, t2 : tag_t) : boolean
    = t1 == t2;
    
    define tag_earlier(t1 : tag_t, t2 : tag_t) : boolean
    = pi1(t1) < pi1(t2)
        || (pi1(t1) == pi1(t2) && pi2(t1) < pi2(t2))
        || (!isInf(t1) && isInf(t2));
    
    // Tag algebra
    define tag_schedule(t : tag_t, i : interval_t) : tag_t
    = if (!isInf(t) && pi1(i) == 0 && !isInf(i))
        then { pi1(t), pi2(t) + 1 } // microstep delay
        else ( if (!isInf(t) && pi1(i) > 0 && !isInf(i))
            then { pi1(t) + pi1(i), 0 }
            else inf());
    
    define tag_delay(t : tag_t, i : interval_t) : tag_t
    = if (!isInf(t) && !isInf(i))
        then { pi1(t) + pi1(i), pi2(t) + pi2(i) }
        else inf();

    define tag_diff(t1, t2 : tag_t) : tag_t
    = {pi1(t1) - pi1(t2), pi2(t1) - pi2(t2)};
    
    /**********************
     * Reactions & States *
     **********************/
    type rxn_t = enum {  
        NULL,                                           // NULL 
        controller_0, controller_1, door_0, train_0     // Reactions
    };

    type state_t = {
        integer, // controller.lock
        integer, // controller.move
        integer, // door.lock
        integer  // train.move
    };
     
    /********************
     * Event Definition *
     ********************/
    type event_t    = { rxn_t, tag_t, state_t };
    //// Array
    type events_t   = [integer]event_t;
    //// Tuple
    /*
    const START : integer = 0;
    const END : integer = 9;
    type events_t = {
        event_t,
        event_t,
        event_t,
        event_t,
        event_t,
        event_t,
        event_t,
        event_t,
        event_t,
        event_t
    };
     
    define get(tr : events_t, i : integer) : event_t 
    = if (i == 0) then tr._1 else (
        if (i == 1) then tr._2 else (
            if (i == 2) then tr._3 else (
                if (i == 3) then tr._4 else (
                    if (i == 4) then tr._5 else (
                        if (i == 5) then tr._6 else (
                            if (i == 6) then tr._7 else (
                                if (i == 7) then tr._8 else (
                                    if (i == 8) then tr._9 else (
                                        if (i == 9) then tr._10 else (
                                            { NULL, inf(), {0,0,0,0} }
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    );
    */
    
    // projection macros
    define rxn      (e : event_t) : rxn_t    = e._1;
    define g        (e : event_t) : tag_t    = e._2;
    define s        (e : event_t) : state_t  = e._3;
    define isNULL   (e : event_t) : boolean  = rxn(e) == NULL;

    // Mark the start of the trace.
    var start : timestamp_t;

    // Declare the current state
    var trace : events_t;

    // Check if in array
    define inTr(E : events_t, e : event_t) : boolean =
        exists (i : integer) :: E[i] == e;
    /*
    define inTr(E : events_t, e : event_t) : boolean =
        exists (i : integer) :: (i >= START && i <= END)
            && get(E, i) == e;
    */

    define rxnInTr(E : events_t, _rxn : rxn_t) : boolean =
        exists (i : integer) :: rxn(E[i]) == _rxn;
    /*
    define rxnInTr(E : events_t, _rxn : rxn_t) : boolean =
        exists (i : integer) :: (i >= START && i <= END)
            && rxn(get(E, i)) == _rxn;
    */

    init {
        assume(
            forall (i : integer) :: rxn(trace[i]) == NULL
        );
        /*
        assume(
            forall (i : integer) :: (i >= START && i <= END)
                ==> rxn(get(trace, i)) == NULL
        );
        */
    }

    next {
        // Update status
        havoc trace; 

        // Each set is a subset of the next set.
        assume(
            forall (j : integer) :: rxn(trace[j]) != NULL 
                ==> inTr(trace', trace[j])
        );
        /*
        assume(
            forall (j : integer) :: (j >= START && j <= END)
                ==> (rxn(get(trace, j)) != NULL ==> inTr(trace', get(trace, j)))
        );
        */

        /*********************
         * Reactor Semantics *
         *********************/
        // This model works but not useful, because
        // when logical delay between controller and
        // train is set to 1, the CEX shows train at
        // (1,0) before door at (0,0). Essentially,
        // messages are not processing in time-stamp
        // order.
        //
        // Solution: do not initialize doorCloses and
        // trainMoves to false. Set them to UNKNOWN
        // instead and tie them to the NULL state. 
        // Then the monotonic assumption
        // will mandate that the door be handled before
        // the delayed train reaction, in order to
        // produce the counterexample.

        /*
        // Tags progress monotonically.
        assume(tag_same(g(state'), g(state)) || tag_later(g(state'), g(state)));

        // The same event can only trigger once in a logical instant.
        assume(g(state) == g(state') ==> id(state) != id(state'));

        // Reaction with higher priority triggers first.
        assume((g(state) == g(state') && same_reactor(id(state), id(state'))) 
            ==> priority(id(state)) < priority(id(state')));

        // Connection delay
        assume((id(ctrl1State) != NULL && id(ctrl2State') != NULL)
            ==> tag_diff(g(ctrl2State'), g(ctrl1State)) == zero());
        assume((id(ctrl2State) != NULL && id(trainState') != NULL)
            ==> tag_diff(g(trainState'), g(ctrl2State)) == zero());
            // ==> tag_diff(g(trainState'), g(ctrl2State)) == {1,0}); // FIXME: this should resolve the CEX, but it doesn't.
        assume((id(ctrl2State) != NULL && id(doorState') != NULL)
            ==> tag_diff(g(doorState'), g(ctrl2State)) == zero());
        */

        // Trigger mechanism
        // If upstream exists, then downstream may exist at the next time advancement.
        assume(
            forall (i : integer) :: rxn(trace'[i]) == door_0
                ==> (exists (j : integer) :: j != i && rxn(trace'[j]) == controller_0)
        );
        /*
        assume(
            forall (i : integer) :: (i >= START && i <= END)
                ==> (rxn(get(trace', i)) == door_0
                    ==> (exists (j : integer) :: j != i && j >= START && j <= END
                        && rxn(get(trace', j)) == controller_0))
        );
        */
    }

    //////////////////////////////////////////////////
    // invariant test : rxnInTr(trace, door_0) ==> !rxnInTr(trace, controller_0);
    invariant test : rxnInTr(trace, door_0) ==> rxnInTr(trace, controller_0);

    control {
        v = induction();
        check;
        print_results;
        v.print_cex;
    }
}
