module main {
 
    /*******************************
     * Time and Related Operations *
     ******************************/
    type timestamp_t = integer; // Unit is nanoseconds
    type microstep_t = integer;
    type tag_t = {
        timestamp_t,
        microstep_t
    };
    // FIXME: in LF, the interval is an integer.
    type interval_t  = tag_t;
    
    // Projection macros
    define pi1(t : tag_t)   : timestamp_t   = t._1;         // Get timestamp from tag
    define pi2(t : tag_t)   : microstep_t   = t._2;         // Get microstep from tag
    
    // Interval constructor
    define zero() : interval_t
    = {0, 0};
    define startup() : interval_t
    = zero();
    define mstep() : interval_t
    = {0, 1};
    define nsec(t : integer) : interval_t
    = {t, 0};
    define usec(t : integer) : interval_t
    = {t * 1000, 0};
    define msec(t : integer) : interval_t
    = {t * 1000000, 0};
    define sec(t : integer) : interval_t
    = {t * 1000000000, 0};
    define inf() : interval_t
    = {-1, 0};
    
    // Helper function
    define isInf(i : interval_t) : boolean
    = pi1(i) < 0;
    
    // Tag comparison
    define tag_later(t1 : tag_t, t2 : tag_t) : boolean
    = pi1(t1) > pi1(t2)
        || (pi1(t1) == pi1(t2) && pi2(t1) > pi2(t2))
        || (isInf(t1) && !isInf(t2));
    
    define tag_same(t1 : tag_t, t2 : tag_t) : boolean
    = t1 == t2;
    
    define tag_earlier(t1 : tag_t, t2 : tag_t) : boolean
    = pi1(t1) < pi1(t2)
        || (pi1(t1) == pi1(t2) && pi2(t1) < pi2(t2))
        || (!isInf(t1) && isInf(t2));
    
    // Tag algebra
    define tag_schedule(t : tag_t, i : interval_t) : tag_t
    = if (!isInf(t) && pi1(i) == 0 && !isInf(i))
        then { pi1(t), pi2(t) + 1 } // microstep delay
        else ( if (!isInf(t) && pi1(i) > 0 && !isInf(i))
            then { pi1(t) + pi1(i), 0 }
            else inf());
    
    define tag_delay(t : tag_t, i : interval_t) : tag_t
    = if (!isInf(t) && !isInf(i))
        then { pi1(t) + pi1(i), pi2(t) + pi2(i) }
        else inf();
    
    // Only consider timestamp for now.
    define tag_diff(t1, t2: tag_t) : interval_t
    = if (!isInf(t1) && !isInf(t2))
        then { pi1(t1) - pi1(t2), pi2(t1) - pi2(t2) }
        else inf();
     
    /**********************************
     * Reactions & connectivity graph *
     *********************************/
    
    //////////////////////////
    // Application Specific
    // Element IDs
    type id_t = enum {  
        NULL,    // NULL 
        AddOne_1 // Reactions
    };

    type state_t = {
        integer, // _in
        integer  // out
    };
    //////////////////////////
     
    /*****************
     * Trace Element *
     ****************/
    type event_t = { id_t, tag_t, state_t };
    
    // Projection macros
    define id(e : event_t) : id_t     = e._1;
    define g(e : event_t) : tag_t     = e._2;
    define s(e : event_t) : state_t   = e._3;

    // Application specific: state variables
    define _in(s : state_t) : integer = s._1;
    define out(s : state_t) : integer = s._2;
    
    define isNULL(e : event_t) : boolean = id(e) == NULL;
     
    /********************
     * Trace Definition *
     *******************/
    const START : integer = 0;
    const END : integer = 9;
    
    define in_range(num : integer) : boolean
    = num >= START && num <= END;
    
    type step_t = integer;
    type trace_t = { 
        event_t,
        event_t,
        event_t,
        event_t,
        event_t,
        event_t,
        event_t,
        event_t,
        event_t,
        event_t
    };
    
    define get(tr : trace_t, i : step_t) : event_t 
    = if (i == 0) then tr._1 else (
        if (i == 1) then tr._2 else (
            if (i == 2) then tr._3 else (
                if (i == 3) then tr._4 else (
                    if (i == 4) then tr._5 else (
                        if (i == 5) then tr._6 else (
                            if (i == 6) then tr._7 else (
                                if (i == 7) then tr._8 else (
                                    if (i == 8) then tr._9 else (
                                        if (i == 9) then tr._10 else (
                                            { NULL, inf(), { 0, 0 } }
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    );

    // Mark the start of the trace.
    var start : timestamp_t;
    assume(start == pi1(zero()));
     
    // Declare the trace
    // The counterexample reflects a particular frame of reference.
    var trace : trace_t;
    
    // Helper macro that returns an element based on index
    define elem(i : integer) : event_t
    = get(trace, i);
     
    /************
     * Topology *
     ************/
    // Return reaction priority.
    define priority(i : id_t) : integer
    = if (i == AddOne_1) then 1 else 999; 
     
    // Return logical delay in a connection.
    define connection_delay(i1, i2 : id_t) : interval_t
    = inf(); 

    // Timer-related constants and macros.
    const NUM_TIMERS : integer = 0;

    define timer_period(i : id_t) : interval_t
    = inf();

    define timer_offset(i : id_t) : interval_t
    = inf();

    /***************************
     * Topological Abstraction *
     ***************************/

    define is_multiple_of(a, b : integer) : boolean
    = exists (c : integer) :: b * c == a;
    
    define is_closest_starting_point(t : tag_t, period : integer, offset : integer) : boolean
    = (exists (c : integer) :: (period * c) + offset == pi1(t)
        // Tick at the next valid instant.
        && (period * (c - 1) + offset) < start)     
        // Timer always has mstep of 0.
        && pi2(t) == 0;                           
    
    // first & last in trace
    define first(e : event_t) : boolean
    = !(exists (i : integer) :: in_range(i) && id(elem(i)) == id(e) && tag_earlier(g(elem(i)), g(e))); 
    
    define last(e : event_t) : boolean
    = !(exists (i : integer) :: in_range(i) && id(elem(i)) == id(e) && tag_later(g(elem(i)), g(e))); 
    
    define is_triggered_by_startup(_id : id_t) : boolean
    = // If startup is within frame, put the events in the trace.
    ((start == 0) ==> (exists (i : integer) :: in_range(i)
        && id(elem(i)) == _id && tag_same(g(elem(i)), startup())))
    // Can only appear once.
    && !(exists (j : integer) :: in_range(j) && id(elem(j)) == _id
        && !tag_same(g(elem(j)), startup()));
    
    // Can directly use index as HB since this only applies to events
    // on the same federate.
    define _is_latest_invocation_in_same_fed_wrt_(a, b : integer) : boolean
    = !(exists (c : integer) :: in_range(c) 
        && id(elem(c)) == id(elem(a)) && a < c && c < b);
    

    // This includes the possibility that upstream does NOT output.
    define is_triggered_by(downstream, upstream : id_t, delay : interval_t) : boolean
    = (forall (i : integer) :: in_range(i) ==>
        id(elem(i)) == downstream ==> (exists (j : integer) :: in_range(j)
            && id(elem(j)) == upstream 
            && g(elem(i)) == tag_schedule(g(elem(j)), delay))
    );
    
    // This macro ensures that the upstream MUST output.
    define is_definitely_triggered_by(downstream, upstream : id_t,
        delay : interval_t) : boolean
    = (forall (i : integer) :: in_range(i) ==>
        id(elem(i)) == downstream ==> (exists (j : integer) :: in_range(j)
            && id(elem(j)) == upstream 
            && g(elem(i)) == tag_schedule(g(elem(j)), delay))
    ) && 
    (forall (j : integer) :: in_range(j) ==>
        id(elem(j)) == upstream ==> (exists (i : integer) :: in_range(i)
            && id(elem(i)) == downstream 
            && g(elem(i)) == tag_schedule(g(elem(j)), delay))
    );
    
    define is_in_trace(_id : id_t) : boolean
    = (exists (i : integer) :: in_range(i) && id(elem(i)) == _id);

    /*********************
     * Reactor Semantics *
     *********************/

    // [Federated] The trace should respect the HB relation.
    // In this case, there is no constraint on i, j when hb
    // fails to establish on both direction (def. of concurrent).
    // axiom(forall (i, j : integer) :: (in_range(i) && in_range(j))
    //     ==> (_hb(elem(i), elem(j)) ==> i < j));

    // [Non-federated] Events are processed in timestamped order.
    axiom(forall (i, j : integer) :: (in_range(i) && in_range(j))
        ==> (tag_earlier(g(elem(i)), g(elem(j))) ==> i < j));
    
    // All microsteps are positive
    axiom(forall (i : integer) :: in_range(i)
        ==> pi2(g(elem(i))) >= 0);
    
    // The same event can only trigger once in a logical instant
    axiom(forall (i, j : integer) :: (in_range(i) && in_range(j))
        ==> ((id(elem(i)) == id(elem(j)) && i != j)
            ==> !tag_same(g(elem(i)), g(elem(j)))));
    
    // NULL events should appear in the suffix
    axiom(forall (j : integer) :: in_range(j) ==> (
        (id(elem(j)) != NULL) ==> (forall (i : integer) :: in_range(i) ==> 
        ((i < j) ==> id(elem(i)) != NULL)
    )));
    
    // All tags should be positive
    axiom(forall (i : integer) :: in_range(i) ==> (
        pi1(g(elem(i))) >= 0
    ));
    
    // Begin the frame at the start time specified.
    axiom(forall (i : integer) :: tag_same(g(elem(i)), {start, 0})
        || tag_later(g(elem(i)), {start, 0}));
     
    /*****************
     * Reaction Body *
     *****************/
    // pre: true
    // post: out == _in + 1
    axiom(forall (i : integer) :: in_range(i) ==> 
        (id(elem(i)) == AddOne_1 ==> 
            out(s(elem(i))) == _in(s(elem(i))) + 1));

    /*******************************
     * Application-specific axioms *
     *******************************/
    // axiom(is_triggered_by_startup(AddOne_1));
     
    /**********************
     * Proof by induction *
     **********************/
    /* Debug case 1 */
    // axiom(exists (i : integer) :: id(elem(i)) == controller_2);
    // property test : false;

    /* Invariant: out should always be (_in + 1). */

    // Inductive
    // define prop(i : integer) : boolean
    //     = (id(elem(i)) == AddOne_1 ==> out(s(elem(i))) == _in(s(elem(i))) + 1);

    // Inductive
    define prop(i : integer) : boolean
        = (id(elem(i)) == AddOne_1 ==> out(s(elem(i))) != _in(s(elem(i))));

    // Not inductive
    // define prop(i : integer) : boolean
    //     = (id(elem(i)) == AddOne_1 ==> out(s(elem(i))) < 10);

    // This is bounded model checking with non-deterministic starting point.
    // property inv : forall (i : integer) :: in_range(i) ==> prop(i);

    // k-induction
    // Initialization
    property initialization : prop(START);

    // Consecution
    property consecution : (forall (i : integer) :: (i >= START && i < END) ==> prop(i))
        ==> prop(END);
     
    //////////////////////////////////////////////////
     
    control {
        v = unroll(0);
        check;
        print_results;
        v.print_cex;
    }
}
