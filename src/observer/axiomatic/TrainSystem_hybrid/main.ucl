/**************************************
 * An axiomatic and operational model *
 **************************************/
module main {
 
    /*******************************
     * Time and Related Operations *
     ******************************/
    type timestamp_t = integer; // Unit is nanoseconds
    type microstep_t = integer;
    type tag_t = {
        timestamp_t,
        microstep_t
    };
    // FIXME: in LF, the interval is an integer.
    type interval_t  = tag_t;
    
    // Projection macros
    define pi1(t : tag_t)   : timestamp_t   = t._1;         // Get timestamp from tag
    define pi2(t : tag_t)   : microstep_t   = t._2;         // Get microstep from tag
    
    // Interval constructor
    define zero() : interval_t
    = {0, 0};
    define startup() : interval_t
    = zero();
    define mstep() : interval_t
    = {0, 1};
    define nsec(t : integer) : interval_t
    = {t, 0};
    define usec(t : integer) : interval_t
    = {t * 1000, 0};
    define msec(t : integer) : interval_t
    = {t * 1000000, 0};
    define sec(t : integer) : interval_t
    = {t * 1000000000, 0};
    define inf() : interval_t
    = {-1, 0};
    
    // Helper function
    define isInf(i : interval_t) : boolean
    = pi1(i) < 0;
    
    // Tag comparison
    define tag_later(t1 : tag_t, t2 : tag_t) : boolean
    = pi1(t1) > pi1(t2)
        || (pi1(t1) == pi1(t2) && pi2(t1) > pi2(t2))
        || (isInf(t1) && !isInf(t2));
    
    define tag_same(t1 : tag_t, t2 : tag_t) : boolean
    = t1 == t2;
    
    define tag_earlier(t1 : tag_t, t2 : tag_t) : boolean
    = pi1(t1) < pi1(t2)
        || (pi1(t1) == pi1(t2) && pi2(t1) < pi2(t2))
        || (!isInf(t1) && isInf(t2));
    
    // Tag algebra
    define tag_schedule(t : tag_t, i : interval_t) : tag_t
    = if (!isInf(t) && pi1(i) == 0 && !isInf(i))
        then { pi1(t), pi2(t) + 1 } // microstep delay
        else ( if (!isInf(t) && pi1(i) > 0 && !isInf(i))
            then { pi1(t) + pi1(i), 0 }
            else inf());
    
    define tag_delay(t : tag_t, i : interval_t) : tag_t
    = if (!isInf(t) && !isInf(i))
        then { pi1(t) + pi1(i), pi2(t) + pi2(i) }
        else inf();
    
    // Only consider timestamp for now.
    define tag_diff(t1, t2: tag_t) : interval_t
    = if (!isInf(t1) && !isInf(t2))
        then { pi1(t1) - pi1(t2), pi2(t1) - pi2(t2) }
        else inf();
     
    /**********************************
     * Reactions & connectivity graph *
     *********************************/
    
    //////////////////////////
    // Application Specific
    // Element IDs
    type id_t = enum {  
        NULL,                                           // NULL 
        controller_1, controller_2, door_1, train_1     // Reactions
    };
    //////////////////////////
     
    /*****************
     * Trace Element *
     ****************/
    type element_t = { id_t, tag_t };
    
    // Projection macros
    define id(e : element_t) : id_t     = e._1;
    define g(e : element_t) : tag_t     = e._2;
    
    define isNULL(e : element_t) : boolean = id(e) == NULL;
     
    // Mark the start of the trace.
    var start : timestamp_t;

    // Declare the current state
    var state : element_t;

    var trainState : element_t;
    var doorState : element_t;
    var ctrlState : element_t;
    var trainMoves : boolean;
    var doorCloses : boolean;
    
    /************
     * Topology *
     ************/
    // Return reaction priority.
    define priority(i : id_t) : integer
    = if (i == controller_1) then 1 else (
        if (i == controller_2) then 2 else (
            if (i == door_1) then 1 else (
                if (i == train_1) then 1 else (
                    999))));
     
    // Triggers

    // Return logical delay in a connection.
    define connection_delay(i1, i2 : id_t) : interval_t
    = if (i1 == controller_2 && i2 == door_1) then zero() else (
        if (i1 == controller_2 && i2 == train_1) then zero() else inf()); 

    define same_reactor(i1, i2 : id_t) : boolean
    = i1 == i2 ||
        (i1 == controller_1 && i2 == controller_2) ||
        (i1 == controller_2 && i2 == controller_1);

    /***************************
     * Topological Abstraction *
     ***************************/

     
    //////////////////////////////////////////////////
    init {
        doorCloses = false;
        trainMoves = false;
        doorState = {NULL, {0,0}};
        trainState = {NULL, {0,0}};
    }

    next {
        havoc state; 

        // Update status
        case
            (id(state) == door_1) : {
                doorCloses' = true;
                doorState' = state;
            }
            (id(state) == train_1) : {
                trainMoves' = true;
                trainState' = state;
            }
            (id(state) == controller_2) : {
                ctrlState' = state;
            }
        esac
        
        /*********************
         * Reactor Semantics *
         *********************/
        // Tags progress monotonically.
        // assume(tag_later(g(state'), g(state)));
        assume(tag_same(g(state'), g(state)));

        // All microsteps are positive.
        assume(pi2(g(state)) >= 0);

        // The same event can only trigger once in a logical instant.
        assume(g(state) == g(state') ==> id(state) != id(state'));

        // Reaction with higher priority triggers first.
        assume((g(state) == g(state') && same_reactor(id(state), id(state'))) 
            ==> priority(id(state)) < priority(id(state')));

        // Connection delay
        // assume((id(ctrlState) != NULL && id(trainState) != NULL)
        //     ==> pi1());
    }

    //////////////////////////////////////////////////
    property prop: trainMoves ==> doorCloses;

    control {
        v = unroll(3);
        check;
        print_results;
        v.print_cex;
    }
}
