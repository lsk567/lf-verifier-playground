/******************************
 * A list of reactor instances.
 * This section should be auto-
 * generated by the transpiler.
 *****************************/
module Reactor_GeneratedDelay {
    type * = Common.*;

    // We need const tuple in UCLID
    var NULL_EVENT : event_t;

    // Ports communicating with RTI
    input t : integer;

    // TODO: rename them to reflect comm. to/from RTI.
    input __in__ : event_t;
    output __out__ : event_t;

    // LF inputs
    var y_in : event_t; // unused so far, but what about multiple triggers?

    // LF outputs, to store values after reaction execution.
    var y_out : event_t; // unused and accounted for by outQ

    // LF state variable
    var y_state : integer;

    // Logical actions
    // Encode in reaction for now

    // Physical actions
    // Cannot handle physical actions until variable bounding
    // in BMC or k-induction works

    // A normal queue implementation using define
    type sq_data_t = event_t;
    type sq_content_t = { sq_data_t,
                          sq_data_t,
                          sq_data_t,
                          sq_data_t,
                          sq_data_t };
    type sq_t = { sq_content_t,
                  integer,  // HEAD
                  integer };  // TAIL
                  // sq_data_t };  // Popped value

    const SIZE : integer = 5;

    define get(q : sq_content_t, i : integer) : sq_data_t
    = if (i == 1) then q._1 else
        (if (i == 2) then q._2 else
            (if (i == 3) then q._3 else
                (if (i == 4) then q._4 else
                    if (i == 5) then q._5 else
                        NULL_EVENT)));

    define set(q : sq_content_t, i : integer, v : sq_data_t) : sq_content_t
    = if (i == 1) then {v, q._2, q._3, q._4, q._5} else
        (if (i == 2) then {q._1, v, q._3, q._4, q._5} else
            (if (i == 3) then {q._1, q._2, v, q._4, q._5} else
                (if (i == 4) then {q._1, q._2, q._3, v, q._5} else (
                    if (i == 5) then {q._1, q._2, q._3, q._4, v} else
                        q))));

    define pushQ(q : sq_t, v : sq_data_t) : sq_t
    = { set(q._1, q._3, v),
        q._2,
        (if (q._3 + 1 > SIZE) then 0 else (q._3 + 1)) };

    define popQ(q : sq_t) : {sq_t, sq_data_t}
    = if (get(q._1, q._2) != NULL_EVENT)
      then  {{ set(q._1, q._2, NULL_EVENT),
                (if (q._2 + 1 > SIZE) then 0 else (q._2 + 1)),
                q._3 }, 
                get(q._1, q._2)}
      else {q, NULL_EVENT};

    // A list of outbound events. Since one event is passed at a time,
    // We need a place to temporary store the events that are not sent yet.
    var outQ : sq_t;
    var __pop__ : { sq_t,
                    sq_data_t };
    
    // A list of reactions
    procedure rxn_y_in()
        modifies y_state, outQ, __out__, __pop__;
    {
        // [ActionDelay.lf:10] self->y_state = y_in->value;
        // y_state = y_in._5; // bug? No because y_in is unused!
        y_state = __in__._5;

        // [ActionDelay.lf:11] schedule(act, MSEC(0));
        outQ = pushQ(outQ, { t + 100,  // Current time + delay
                GeneratedDelay,      // Origin
                GeneratedDelay,      // Destination
                GeneratedDelay_act,  // Trigger for destination
                -999,  // Payload
                true   // True 
                });
        
        // Pop a value from outQ
        // Handled in the reaction procedure for now since
        // we need a sequential update to outQ.
        /*
        outQ = popQ(outQ);
        __out__ = outQ._4;
        */
        __pop__ = popQ(outQ);
        outQ = __pop__._1;
        __out__ = __pop__._2;
    }

    procedure rxn_act()
        modifies outQ, __out__, __pop__;
    {
        // [ActionDelay.lf:15] SET(y_out, self->y_state);
        outQ = pushQ(outQ, { t + 0,  // Current time 
                GeneratedDelay,  // Origin
                Sink,            // Destination
                Sink_in,         // Trigger for destination
                y_state,  // Payload
                true      // True 
                });

        // Pop a value from outQ
        /*
        outQ = popQ(outQ);
        __out__ = outQ._4;
        */
        __pop__ = popQ(outQ);
        outQ = __pop__._1;
        __out__ = __pop__._2;
    }

    init {
        NULL_EVENT = { -1, NULL, NULL, N_NULL, -1, false };
        __out__ = NULL_EVENT;

        // Find out if this is needed.
        assume(__in__ == NULL_EVENT);

        outQ = { { NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT },
                 1, 1};

        y_in = NULL_EVENT;
        y_out = NULL_EVENT;
        y_state = 0;
    }

    next {
        if (__in__ != NULL_EVENT) {
            case
                (__in__._4 == GeneratedDelay_y_in) : {
                    call () = rxn_y_in();
                }
                (__in__._4 == GeneratedDelay_act) : {
                    call () = rxn_act();
                }
            esac

            // __out__ gets its value inside the reactions.
        }
        else {
            // outQ' = popQ(outQ);
            // __out__' = outQ'._4;
            __pop__' = popQ(outQ);
            outQ' = __pop__'._1;
            __out__' = __pop__'._2;
        }
    }
}

module Reactor_Source {
    type * = Common.*;

    // We need const tuple in UCLID
    var NULL_EVENT : event_t;

    // Ports communicating with RTI
    input t : integer;

    // TODO: rename them to reflect comm. to/from RTI.
    input __in__ : event_t;
    output __out__ : event_t;

    // LF outputs, to store values after reaction execution.
    var out : event_t; // unused and accounted for by outQ

    // A normal queue implementation using define
    type sq_data_t = event_t;
    type sq_content_t = { sq_data_t,
                          sq_data_t,
                          sq_data_t,
                          sq_data_t,
                          sq_data_t };
    type sq_t = { sq_content_t,
                  integer,  // HEAD
                  integer };  // TAIL
                  // sq_data_t };  // Popped value

    const SIZE : integer = 5;

    define get(q : sq_content_t, i : integer) : sq_data_t
    = if (i == 1) then q._1 else
        (if (i == 2) then q._2 else
            (if (i == 3) then q._3 else
                (if (i == 4) then q._4 else
                    if (i == 5) then q._5 else
                        NULL_EVENT)));

    define set(q : sq_content_t, i : integer, v : sq_data_t) : sq_content_t
    = if (i == 1) then {v, q._2, q._3, q._4, q._5} else
        (if (i == 2) then {q._1, v, q._3, q._4, q._5} else
            (if (i == 3) then {q._1, q._2, v, q._4, q._5} else
                (if (i == 4) then {q._1, q._2, q._3, v, q._5} else (
                    if (i == 5) then {q._1, q._2, q._3, q._4, v} else
                        q))));

    define pushQ(q : sq_t, v : sq_data_t) : sq_t
    = { set(q._1, q._3, v),
        q._2,
        (if (q._3 + 1 > SIZE) then 0 else (q._3 + 1)) };

    define popQ(q : sq_t) : {sq_t, sq_data_t}
    = if (get(q._1, q._2) != NULL_EVENT)
      then  {{ set(q._1, q._2, NULL_EVENT),
                (if (q._2 + 1 > SIZE) then 0 else (q._2 + 1)),
                q._3 }, 
                get(q._1, q._2)}
      else {q, NULL_EVENT};

    /*
    define pushQ(q : sq_t, v : sq_data_t) : sq_t
    = { set(q._1, q._3, v),
        q._2,
        (if (q._3 + 1 > SIZE) then 0 else (q._3 + 1)),
        NULL_EVENT };
    define popQ(q : sq_t) : sq_t
    = if (get(q._1, q._2) != NULL_EVENT)
      then  { set(q._1, q._2, NULL_EVENT),
                (if (q._2 + 1 > SIZE) then 0 else (q._2 + 1)),
                q._3,
                get(q._1, q._2) }
      else q;
    */

    // A list of outbound events. Since one event is passed at a time,
    // We need a place to temporary store the events that are not sent yet.
    var outQ : sq_t;
    var __pop__ : { sq_t, 
                    sq_data_t };
    
    // A list of reactions
    procedure rxn_startup()
        modifies outQ, __out__, __pop__;
    {
        // [ActionDelay.lf:22] SET(out, 1);
        outQ = pushQ(outQ, { t + 0,  // Current time + delay
                Source,      // Origin
                GeneratedDelay,      // Destination
                GeneratedDelay_y_in,  // Trigger for destination
                1,  // Payload
                true   // True 
                });
        // Pop a value from outQ
        // Handled in the reaction procedure for now since
        // we need a sequential update to outQ.
        __pop__ = popQ(outQ);
        outQ = __pop__._1;
        __out__ = __pop__._2;
        // outQ = popQ(outQ);
        // __out__ = outQ._4;
        // outQ._4 = NULL_EVENT; // reset
    }

    init {
        NULL_EVENT = { -1, NULL, NULL, N_NULL, -1, false };
        __out__ = NULL_EVENT;

        // Find out if this is needed.
        assume(__in__ == NULL_EVENT);

        outQ = { { NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT },
                 1, 1};
        
        __pop__ = {outQ, NULL_EVENT};

        // File specific
    }

    next {
        if (__in__ != NULL_EVENT) {
            case
                // File specific
                (__in__._4 == Source_startup) : {
                    call () = rxn_startup();
                }
            esac

            // __out__ gets its value inside the reactions.
        }
        else {
            // outQ', __out__' = popQ(outQ);
            // __out__' = outQ'._4;
            __pop__' = popQ(outQ);
            outQ' = __pop__'._1;
            __out__' = __pop__'._2;
        }
    }
}

module Reactor_Sink {
    type * = Common.*;

    // We need const tuple in UCLID
    var NULL_EVENT : event_t;

    // Ports communicating with RTI
    input t : integer;

    // TODO: rename them to reflect comm. to/from RTI.
    input __in__ : event_t;
    output __out__ : event_t;

    // LF input
    // var _in : event_t; // unused

    // A normal queue implementation using define
    type sq_data_t = event_t;
    type sq_content_t = { sq_data_t,
                          sq_data_t,
                          sq_data_t,
                          sq_data_t,
                          sq_data_t };
    type sq_t = { sq_content_t,
                  integer,  // HEAD
                  integer };  // TAIL
                  // sq_data_t };  // Popped value

    const SIZE : integer = 5;

    define get(q : sq_content_t, i : integer) : sq_data_t
    = if (i == 1) then q._1 else
        (if (i == 2) then q._2 else
            (if (i == 3) then q._3 else
                (if (i == 4) then q._4 else
                    if (i == 5) then q._5 else
                        NULL_EVENT)));

    define set(q : sq_content_t, i : integer, v : sq_data_t) : sq_content_t
    = if (i == 1) then {v, q._2, q._3, q._4, q._5} else
        (if (i == 2) then {q._1, v, q._3, q._4, q._5} else
            (if (i == 3) then {q._1, q._2, v, q._4, q._5} else
                (if (i == 4) then {q._1, q._2, q._3, v, q._5} else (
                    if (i == 5) then {q._1, q._2, q._3, q._4, v} else
                        q))));

    define pushQ(q : sq_t, v : sq_data_t) : sq_t
    = { set(q._1, q._3, v),
        q._2,
        (if (q._3 + 1 > SIZE) then 0 else (q._3 + 1)) };

    define popQ(q : sq_t) : {sq_t, sq_data_t}
    = if (get(q._1, q._2) != NULL_EVENT)
      then  {{ set(q._1, q._2, NULL_EVENT),
                (if (q._2 + 1 > SIZE) then 0 else (q._2 + 1)),
                q._3 }, 
                get(q._1, q._2)}
      else {q, NULL_EVENT};

    // A list of outbound events. Since one event is passed at a time,
    // We need a place to temporary store the events that are not sent yet.
    var outQ : sq_t;
    var __pop__ : { sq_t, 
                    sq_data_t };

    // A list of reactions
    procedure rxn_in()
        modifies outQ, __out__, __pop__;
    {
        // [ActionDelay.lf:11] schedule(act, MSEC(0));
        outQ = pushQ(outQ, { t + 0,  // Current time + delay
                Sink,      // Origin
                NULL,      // Destination
                N_NULL,  // Trigger for destination
                __in__._5,  // Payload
                true   // True 
                });
        
        // Pop a value from outQ
        // Handled in the reaction procedure for now since
        // we need a sequential update to outQ.
        // outQ = popQ(outQ);
        // __out__ = outQ._4;
        __pop__ = popQ(outQ);
        outQ = __pop__._1;
        __out__ = __pop__._2;
    }

    init {
        NULL_EVENT = { -1, NULL, NULL, N_NULL, -1, false };
        __out__ = NULL_EVENT;

        // Find out if this is needed.
        assume(__in__ == NULL_EVENT);

        /*
        outQ = { { NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT },
                 1, 1, NULL_EVENT};
        */

        outQ = { { NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT },
                 1, 1};
        
        __pop__ = {outQ, NULL_EVENT};
        // File specific
    }

    next {
        if (__in__ != NULL_EVENT) {
            case
                // File specific
                (__in__._4 == Sink_in) : {
                    call () = rxn_in();
                }
            esac

            // __out__ gets its value inside the reactions.
        }
        else {
            // outQ' = popQ(outQ);
            // __out__' = outQ'._4;
            __pop__' = popQ(outQ);
            outQ' = __pop__'._1;
            __out__' = __pop__'._2;
        }
    }
}

