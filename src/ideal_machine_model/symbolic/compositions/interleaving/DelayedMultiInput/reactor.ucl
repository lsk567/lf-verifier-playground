/******************************
 * A list of reactor instances.
 * This section should be auto-
 * generated by the transpiler.
 *****************************/

module Reactor_SourceA {
    type * = SimpleQueue.*;
    define * = SimpleQueue.*;
    define * = Common.*;
    type * = Finalized.*;

    // We need const tuple in UCLID
    var NULL_EVENT : event_t;

    // Ports communicating with RTI
    input t : integer;

    // TODO: rename them to reflect comm. to/from RTI.
    input __in__ : event_t;
    output __out__ : event_t;

    // Finalized table
    input finalized : final_tb_t;
    output finalize_SourceA_startup : boolean;

    // LF inputs
    var startup : event_t; // This is implicit and will be required to standardize translation.

    // LF outputs, to store values after reaction execution.
    var out : event_t; // unused and accounted for by outQ

    // LF state variable
    var i : integer;

    // Logical actions
    // Encode in reaction for now

    // Physical actions
    // Cannot handle physical actions until variable bounding
    // in BMC or k-induction works

    // A list of outbound events. Since one event is passed at a time,
    // We need a place to temporary store the events that are not sent yet.
    var outQ : sq_t;
    var __pop__ : { sq_t,
                    sq_data_t };
    
    // File specific
    define all_inputs_empty () : boolean
    = !(is_present(startup));

    // A list of reactions
    procedure rxn_startup()
        modifies i; 
        modifies startup; // Action to be cleared.
        modifies outQ, __out__, __pop__; // Internal
        modifies finalize_SourceA_startup;
    {
        // [ActionDelay.lf:11] schedule(act, MSEC(0));
        outQ = pushQ(outQ, { t,  // Current time + delay
                SourceA,      // Origin
                Sink,      // Destination
                Sink_inA,  // Trigger for destination
                i,  // Payload
                true   // True 
                });
        
        // Pop a value from outQ
        // Handled in the reaction procedure for now since
        // we need a sequential update to outQ.
        __pop__ = popQ(outQ);
        outQ = __pop__._1;
        __out__ = __pop__._2;

        // Clear inputs
        startup = NULL_EVENT;

        // Update finalized table
        finalize_SourceA_startup = true;
    }

    init {
        NULL_EVENT = { -1, NULL, NULL, NULL_NULL, -1, false };
        __out__ = NULL_EVENT;

        // Find out if this is needed.
        assume(__in__ == NULL_EVENT);

        outQ = { { NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT },
                 1, 1};

        // File specific
        // [MultiInput.lf:4] state i:int(3);
        i = 3;
        out = NULL_EVENT;

        // Clear startup action
        startup = NULL_EVENT;

        // Init finalized table
        finalize_SourceA_startup = false;
    }

    next {
        // File specific
        // Load __in__ onto respective input variables
        if (is_present(__in__)) {
            // Loading inputs
            case 
                (__in__._4 == SourceA_startup) : {
                    startup' = __in__;
                }
            esac

            // Reset finalize_ outputs at new logical time, which is
            // denoted by a new finalized table
            if (finalized == {false, false, false, false, false, false}) {
                finalize_SourceA_startup' = false;
            }
        }
        else {
            // Trigger reaction
            case
                // No need to check the finalized table here because
                // reaction to startup action has no prior reactions
                (is_present(startup)) : {
                    call () = rxn_startup();
                }
                // Potentially problematic, since but inputs are not empty but finalized table not passed
                // outQ is still not popped.
                (all_inputs_empty()) : {
                    __pop__' = popQ(outQ);
                    outQ' = __pop__'._1;
                    __out__' = __pop__'._2;
                }
            esac
        }
    }
}

module Reactor_SourceB {
    type * = SimpleQueue.*;
    define * = SimpleQueue.*;
    define * = Common.*;
    type * = Finalized.*;

    // We need const tuple in UCLID
    var NULL_EVENT : event_t;

    // Ports communicating with RTI
    input t : integer;

    // TODO: rename them to reflect comm. to/from RTI.
    input __in__ : event_t;
    output __out__ : event_t;
    
    // Finalized table
    input finalized : final_tb_t;
    output finalize_SourceB_startup : boolean;

    // LF inputs
    var startup : event_t; // This is implicit and will be required to standardize translation.

    // LF outputs, to store values after reaction execution.
    var out : event_t; // unused and accounted for by outQ

    // LF state variable
    var j : integer;

    // Logical actions
    // Encode in reaction for now

    // Physical actions
    // Cannot handle physical actions until variable bounding
    // in BMC or k-induction works

    // A list of outbound events. Since one event is passed at a time,
    // We need a place to temporary store the events that are not sent yet.
    var outQ : sq_t;
    var __pop__ : { sq_t,
                    sq_data_t };
    
    // File specific
    define all_inputs_empty () : boolean
    = !(is_present(startup));

    // A list of reactions
    procedure rxn_startup()
        modifies j; 
        modifies startup; // Action to be cleared.
        modifies outQ, __out__, __pop__; // Internal
        modifies finalize_SourceB_startup;
    {
        // [ActionDelay.lf:11] schedule(act, MSEC(0));
        outQ = pushQ(outQ, { t,  // Current time + delay
                SourceB,      // Origin
                SourceC,      // Destination
                SourceC_in,  // Trigger for destination
                j,  // Payload
                true   // True 
                });
        
        // Pop a value from outQ
        // Handled in the reaction procedure for now since
        // we need a sequential update to outQ.
        __pop__ = popQ(outQ);
        outQ = __pop__._1;
        __out__ = __pop__._2;

        // Clear inputs
        startup = NULL_EVENT;

        // Update finalized table
        finalize_SourceB_startup = true;
    }

    init {
        NULL_EVENT = { -1, NULL, NULL, NULL_NULL, -1, false };
        __out__ = NULL_EVENT;

        // Find out if this is needed.
        assume(__in__ == NULL_EVENT);

        outQ = { { NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT },
                 1, 1};

        // File specific
        // [MultiInput.lf:4] state i:int(3);
        j = 7;
        out = NULL_EVENT;
        startup = NULL_EVENT;

        // Init finalized table
        finalize_SourceB_startup = false;
    }

    next {
        // File specific
        // Load __in__ onto respective input variables
        if (is_present(__in__)) {
            case 
                (__in__._4 == SourceB_startup) : {
                    startup' = __in__;
                }
            esac

            // Reset finalize_ outputs at new logical time, which is
            // denoted by a new finalized table
            if (finalized == {false, false, false, false, false, false}) {
                finalize_SourceB_startup' = false;
            }
        }
        else {
            // Trigger reaction
            case
                (is_present(startup)) : {
                    call () = rxn_startup();
                }
                (all_inputs_empty()) : {
                    __pop__' = popQ(outQ);
                    outQ' = __pop__'._1;
                    __out__' = __pop__'._2;
                }
            esac
        }
    }
}

module Reactor_SourceC {
    type * = SimpleQueue.*;
    define * = SimpleQueue.*;
    define * = Common.*;
    type * = Finalized.*;

    // We need const tuple in UCLID
    var NULL_EVENT : event_t;

    // Ports communicating with RTI
    input t : integer;

    // TODO: rename them to reflect comm. to/from RTI.
    input __in__ : event_t;
    output __out__ : event_t;

    // Finalized table
    input finalized : final_tb_t;
    output finalize_SourceC_in : boolean;

    // LF inputs
    var _in : event_t;

    // LF outputs, to store values after reaction execution.
    var out : event_t; // unused and accounted for by outQ

    // A list of outbound events. Since one event is passed at a time,
    // We need a place to temporary store the events that are not sent yet.
    var outQ : sq_t;
    var __pop__ : { sq_t,
                    sq_data_t };
    
    // File specific
    define all_inputs_empty () : boolean
    = !(is_present(_in));

    // A list of reactions
    procedure rxn_in()
        modifies _in, out;
        modifies outQ, __out__, __pop__; // Internal
        modifies finalize_SourceC_in;
    {
        // [ActionDelay.lf:11] schedule(act, MSEC(0));
        outQ = pushQ(outQ, { t,  // Current time + delay
                SourceC,      // Origin
                SourceD,      // Destination
                SourceD_in,  // Trigger for destination
                _in._5,  // Payload
                true   // True 
                });
        
        // Pop a value from outQ
        // Handled in the reaction procedure for now since
        // we need a sequential update to outQ.
        __pop__ = popQ(outQ);
        outQ = __pop__._1;
        __out__ = __pop__._2;

        // Clear inputs
        _in = NULL_EVENT;
        out = NULL_EVENT;

        // Update finalized table
        finalize_SourceC_in = true;
    }

    init {
        NULL_EVENT = { -1, NULL, NULL, NULL_NULL, -1, false };
        __out__ = NULL_EVENT;

        // Find out if this is needed.
        assume(__in__ == NULL_EVENT);

        outQ = { { NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT },
                 1, 1};

        // File specific: init input/output/state variable
        _in = NULL_EVENT;
        out = NULL_EVENT;

        // Init finalized table
        finalize_SourceC_in = false;
    }

    next {
        // File specific
        // Load __in__ onto respective input variables
        if (is_present(__in__)) {
            case 
                (__in__._4 == SourceC_in) : {
                    _in' = __in__;
                }
            esac

            // Reset finalize_ outputs at new logical time, which is
            // denoted by a new finalized table
            if (finalized == {false, false, false, false, false, false}) {
                finalize_SourceC_in' = false;
            }
        }
        else {
            // Trigger reaction
            case
                (finalized._2 == true
                && is_present(_in)) : {
                    call () = rxn_in();
                }
                (all_inputs_empty()) : {
                    __pop__' = popQ(outQ);
                    outQ' = __pop__'._1;
                    __out__' = __pop__'._2;
                }
            esac
        }
    }
}

module Reactor_SourceD {
    type * = SimpleQueue.*;
    define * = SimpleQueue.*;
    define * = Common.*;
    type * = Finalized.*;

    // We need const tuple in UCLID
    var NULL_EVENT : event_t;

    // Ports communicating with RTI
    input t : integer;

    // TODO: rename them to reflect comm. to/from RTI.
    input __in__ : event_t;
    output __out__ : event_t;

    // Finalized table
    input finalized : final_tb_t;
    output finalize_SourceD_in : boolean;

    // LF inputs
    var _in : event_t;

    // LF outputs, to store values after reaction execution.
    var out : event_t; // unused and accounted for by outQ

    // A list of outbound events. Since one event is passed at a time,
    // We need a place to temporary store the events that are not sent yet.
    var outQ : sq_t;
    var __pop__ : { sq_t,
                    sq_data_t };
    
    // File specific
    define all_inputs_empty () : boolean
    = !(is_present(_in));

    // A list of reactions
    procedure rxn_in()
        modifies _in, out;
        modifies outQ, __out__, __pop__; // Internal
        modifies finalize_SourceD_in;
    {
        // [ActionDelay.lf:11] schedule(act, MSEC(0));
        outQ = pushQ(outQ, { t,  // Current time + delay
                SourceD,      // Origin
                Sink,      // Destination
                Sink_inB,  // Trigger for destination
                _in._5,  // Payload
                true   // True 
                });
        
        // Pop a value from outQ
        // Handled in the reaction procedure for now since
        // we need a sequential update to outQ.
        __pop__ = popQ(outQ);
        outQ = __pop__._1;
        __out__ = __pop__._2;

        // Clear inputs
        _in = NULL_EVENT;
        out = NULL_EVENT;

        // Update finalized table
        finalize_SourceD_in = true;
    }

    init {
        NULL_EVENT = { -1, NULL, NULL, NULL_NULL, -1, false };
        __out__ = NULL_EVENT;

        // Find out if this is needed.
        assume(__in__ == NULL_EVENT);

        outQ = { { NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT },
                 1, 1};

        // File specific: init input/output/state variable
        _in = NULL_EVENT;
        out = NULL_EVENT;

        // Init all finalize_ flags here
        finalize_SourceD_in = false;
    }

    next {
        // File specific
        // Load __in__ onto respective input variables
        if (is_present(__in__)) {
            case 
                (__in__._4 == SourceD_in) : {
                    _in' = __in__;
                }
            esac

            // Reset finalize_ outputs at new logical time, which is
            // denoted by a new finalized table
            if (finalized == {false, false, false, false, false, false}) {
                finalize_SourceD_in' = false;
            }
        }
        else {
            // Trigger reaction
            case
                (finalized._3 == true
                && is_present(_in)) : {
                    call () = rxn_in();
                }
                (all_inputs_empty()) : {
                    __pop__' = popQ(outQ);
                    outQ' = __pop__'._1;
                    __out__' = __pop__'._2;
                }
            esac
        }
    }
}

module Reactor_Sink {
    type * = SimpleQueue.*;
    define * = SimpleQueue.*;
    define * = Common.*;
    type * = Finalized.*;

    // We need const tuple in UCLID
    var NULL_EVENT : event_t;

    // Ports communicating with RTI
    input t : integer;

    // TODO: rename them to reflect comm. to/from RTI.
    input __in__ : event_t;
    output __out__ : event_t;

    // Finalized table
    input finalized : final_tb_t;
    output finalize_Sink_inA : boolean;
    output finalize_Sink_inB : boolean;

    // LF inputs
    var inA : event_t;
    var inB : event_t;

    // LF state variable
    var s : integer;

    // Logical actions
    // Encode in reaction for now

    // Physical actions
    // Cannot handle physical actions until variable bounding
    // in BMC or k-induction works

    // A list of outbound events. Since one event is passed at a time,
    // We need a place to temporary store the events that are not sent yet.
    var outQ : sq_t;
    var __pop__ : { sq_t,
                    sq_data_t };
    
    // File specific
    define all_inputs_empty () : boolean
    = !(is_present(inA)
        || is_present(inB));

    // A list of reactions
    procedure rxn_inA_inB()
        modifies s; // State variable
        modifies inA, inB; // Inputs to be cleared.
        modifies outQ, __out__, __pop__; // Internal
        modifies finalize_Sink_inA, finalize_Sink_inB;
    {
        /*****************
         * Reaction body *
         *****************/
        // [MultiInput.lf] self->s = inA->value + inB->value;
        s = inA._5 + inB._5;

        // [ActionDelay.lf:11] schedule(act, MSEC(0));
        outQ = pushQ(outQ, { t,  // Current time + delay
                Sink,      // Origin
                NULL,      // Destination
                NULL_NULL, // Trigger for destination
                s,      // Payload
                true    // True 
                });
        
        /*******************
         * Post-processing *
         *******************/
        // Pop a value from outQ
        // Handled in the reaction procedure for now since
        // we need a sequential update to outQ.
        __pop__ = popQ(outQ);
        outQ = __pop__._1;
        __out__ = __pop__._2;

        // Clear inputs
        inA = NULL_EVENT;
        inB = NULL_EVENT;

        // Update finalized table
        // TODO: define reaction_id_t in common and use that one 
        finalize_Sink_inA = true;
        finalize_Sink_inB = true;
    }

    init {
        NULL_EVENT = { -1, NULL, NULL, NULL_NULL, -1, false };
        __out__ = NULL_EVENT;

        // Find out if this is needed.
        assume(__in__ == NULL_EVENT);

        outQ = { { NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT },
                 1, 1};

        // File specific: init input/output/state variable
        inA = NULL_EVENT;
        inB = NULL_EVENT;

        // Init all finalize_ flags here
        finalize_Sink_inA = false;
        finalize_Sink_inB = false;
    }

    next {
        // File specific
        // Load __in__ onto respective input variables
        if (is_present(__in__)) {
            case 
                (__in__._4 == Sink_inA) : {
                    inA' = __in__;
                }
                (__in__._4 == Sink_inB) : {
                    inB' = __in__;
                }
            esac

            // Reset finalize_ outputs at new logical time, which is
            // denoted by a new finalized table
            if (finalized == {false, false, false, false, false, false}) {
                finalize_Sink_inA' = false;
                finalize_Sink_inB' = false;
            }
        }
        else {
            // Trigger reaction
            case
                (finalized._1 == true && finalized._4 == true
                && (is_present(inA) || is_present(inB))) : {
                    call () = rxn_inA_inB();
                }
                (all_inputs_empty()) : {
                    __pop__' = popQ(outQ);
                    outQ' = __pop__'._1;
                    __out__' = __pop__'._2;
                }
            esac
        }
    }
}
