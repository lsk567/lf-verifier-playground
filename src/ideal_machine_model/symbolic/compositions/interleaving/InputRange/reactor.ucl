/******************************
 * A list of reactor instances.
 * This section should be auto-
 * generated by the transpiler.
 *****************************/
// File specific: reactor name
module Reactor_A {
    type * = SimpleQueue.*;
    define * = SimpleQueue.*;
    define * = Common.*;
    type * = Finalized.*;

    /*******************************
     * File specific: LF variables *
     *******************************/
    // LF inputs
    var startup : event_t;

    // LF outputs
    var out : event_t;

    // LF state variables
    var s : integer;

    /**********************
     * Internal variables *
     **********************/
    // We need const tuple in UCLID
    var NULL_EVENT : event_t;

    // Time, scheduler input, scheduler output
    input t : integer;
    input __in__ : event_t;
    output __out__ : event_t;

    // Finalized table
    input finalized : final_tb_t;

    // File specific: LF inputs finalized entry
    output finalize_A_startup : boolean;

    // A list of outbound events. Since one event is passed at a time,
    // We need a place to temporary store the events that are not sent yet.
    var outQ : sq_t;
    var __pop__ : { sq_t,
                    sq_data_t };
    
    // File specific
    define all_inputs_empty () : boolean
    = true;

    /*************
     * Reactions *
     *************/
    procedure rxn_startup()
        modifies s;
        modifies startup; // State variable
        modifies outQ, __out__, __pop__; // Internal
        modifies finalize_A_startup;
    {
        /*****************
         * Reaction body *
         *****************/
        havoc s;
        assume(s >= 0 && s <= 5);

        // [PartialOrderExec.lf:16] SET(outA, 1);
        outQ = pushQ(outQ, { t,  // Current time + delay
                A,      // Origin
                B,      // Destination
                B_in, // Trigger for destination
                s,      // Payload
                true    // True 
                });

        /*******************
         * Post-processing *
         *******************/
        // Pop a value from outQ
        // Handled in the reaction procedure for now since
        // we need a sequential update to outQ.
        __pop__ = popQ(outQ);
        outQ = __pop__._1;
        __out__ = __pop__._2;

        // Clear inputs
        startup = NULL_EVENT;

        // Update finalized table
        finalize_A_startup = true;
    }

    init {
        NULL_EVENT = { -1, NULL, NULL, NULL_NULL, -1, false };
        __out__ = NULL_EVENT;

        // "Setting" the input.
        assume(__in__ == NULL_EVENT);

        outQ = { { NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT },
                 1, 1};

        // File specific: init input/output/state variable
        startup = NULL_EVENT;
        s = 0;

        // File specific: init all finalize_ flags here
        finalize_A_startup = false;
    }

    next {
        // File specific: load __in__ onto respective input variables
        if (is_present(__in__)) {
            case 
                (__in__._4 == A_startup) : {
                    startup' = __in__;
                }
            esac

            // File specific
            // Reset finalize_ outputs at new logical time, which is
            // denoted by a new finalized table
            if (finalized == {false, false}) {
                finalize_A_startup' = false;
            }
        }
        else {
            // File specific: trigger reaction
            case
                (is_present(startup)) : {
                    call () = rxn_startup();
                }
                (all_inputs_empty()) : {
                    __pop__' = popQ(outQ);
                    outQ' = __pop__'._1;
                    __out__' = __pop__'._2;
                }
            esac
        }
    }
}

// File specific: reactor name
module Reactor_B {
    type * = SimpleQueue.*;
    define * = SimpleQueue.*;
    define * = Common.*;
    type * = Finalized.*;

    /*******************************
     * File specific: LF variables *
     *******************************/
    // LF state variables
    var s : integer;

    // LF outputs
    var _in : event_t;

    /**********************
     * Internal variables *
     **********************/
    // We need const tuple in UCLID
    var NULL_EVENT : event_t;

    // Time, scheduler input, scheduler output
    input t : integer;
    input __in__ : event_t;
    output __out__ : event_t;

    // Finalized table
    input finalized : final_tb_t;

    // File specific: LF inputs finalized entry
    output finalize_B_in : boolean;

    // A list of outbound events. Since one event is passed at a time,
    // We need a place to temporary store the events that are not sent yet.
    var outQ : sq_t;
    var __pop__ : { sq_t,
                    sq_data_t };
    
    // File specific
    define all_inputs_empty () : boolean
    = true;

    /*************
     * Reactions *
     *************/
    procedure rxn_in()
        modifies s;
        modifies outQ, __out__, __pop__; // Internal
        modifies _in;
        modifies finalize_B_in;
    {
        // Gametime
        // basis traces, composition of traces
        // exec. time depends on inputs.
        // cross-time instance
        //
        // leverage induction to prove unbounded properties
        // do bmc first, then try induction.
        // try k-induction. BMC starting from arbitrary step
        // transition k steps, and eventually perform the inductive step.
        /*****************
         * Reaction body *
         *****************/
        s = s + _in._5;

        // [PartialOrderExec.lf:35] printf("B says hi.\n");
        outQ = pushQ(outQ, { t,  // Current time + delay
                B,      // Origin
                NULL,      // Destination
                NULL_NULL, // Trigger for destination
                s,      // Payload
                true    // True 
                });

        /*******************
         * Post-processing *
         *******************/
        // Pop a value from outQ
        // Handled in the reaction procedure for now since
        // we need a sequential update to outQ.
        __pop__ = popQ(outQ);
        outQ = __pop__._1;
        __out__ = __pop__._2;

        // Clear inputs
        _in = NULL_EVENT;

        // Update finalized table
        finalize_B_in = true;
    }

    init {
        NULL_EVENT = { -1, NULL, NULL, NULL_NULL, -1, false };
        __out__ = NULL_EVENT;

        // "Setting" the input.
        assume(__in__ == NULL_EVENT);

        outQ = { { NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT,
                 NULL_EVENT },
                 1, 1};

        // File specific: init input/output/state variable
        _in = NULL_EVENT;

        // File specific: init all finalize_ flags here
        finalize_B_in = false;

        // Usually initialized via a startup reaction
        s = 5; // Spare a startup action for convenience.
    }

    next {
        // File specific: load __in__ onto respective input variables
        if (is_present(__in__)) {
            case 
                (__in__._4 == B_in) : {
                    _in' = __in__;
                }
            esac

            // File specific:
            // Reset finalize_ outputs at new logical time, which is
            // denoted by a new finalized table
            if (finalized == {false, false}) {
                finalize_B_in' = false;
            }
        }
        else {
            // Trigger reaction
            case
                (is_present(_in)) : {
                    call () = rxn_in();
                }
                (all_inputs_empty()) : {
                    __pop__' = popQ(outQ);
                    outQ' = __pop__'._1;
                    __out__' = __pop__'._2;
                }
            esac
        }
    }
}

