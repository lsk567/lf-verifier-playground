/******************************
 * A list of reactor instances.
 * This section should be auto-
 * generated by the transpiler.
 *****************************/
module Reactor_A {
    type * = Common.*;

    // We need const tuple in UCLID
    var NULL_EVENT : event_t;

    // Ports communicating with RTI
    input t : integer;
    // TODO: rename them to reflect comm. to/from RTI.
    input __in__ : event_t;
    output __out__ : event_t;

    // LF inputs
    // There isn't any in reactor A.

    // LF state variables
    // There isn't any in reactor A.

    // LF outputs, to store values after reaction execution.
    var _out : event_t; // output _out:int;

    // A list of outbound events. Since one event is passed at a time,
    // We need a place to temporary store the events that are not sent yet.
    // TODO

    // A list of reactions
    procedure rxn_startup()
        returns (ret : event_t)
    {
        // Much of the information can be hardcoded into the program.
        // Variables will be introduced when there are runtime mutations.
        ret = { t,  // Current time 
                A,  // Origin, which is A in this case
                B,  // Destination, can be generated based on the precedence graph at compiletime
                B_IN, // Trigger for destination
                1,  // Payload, which is 1 based on the target code
                true // True since this is not an NULL_EVENT.
                };
    }

    init {
        NULL_EVENT = { -1, NULL, NULL, NULL_NULL, -1, false };
        __out__ = NULL_EVENT;
        _out = NULL_EVENT;

        // Note; startup action initialization now in EventQ init{}.

        assume(__in__ == NULL_EVENT);
    }

    next {
        if (__in__ != NULL_EVENT) {
            case
                (__in__._4 == A_STARTUP) : {
                    call (_out') = rxn_startup();
                    // TODO: push _out' into the outbound buffer
                    // can be implemented using an array and 2 vars (hd & tl)
                }
            esac

            // TODO: pop event from outbound buffer
            __out__' = _out';
        }
        else {
            __out__' = NULL_EVENT;
        }
    }
}


module Reactor_B {
    type * = Common.*;

    // We need const tuple in UCLID
    var NULL_EVENT : event_t;

    // Ports communicating with RTI
    input t : integer;
    input __in__ : event_t;
    output __out__ : event_t;

    // LF inputs
    var _in : event_t; 

    // LF state variables
    var s : integer;

    // LF outputs, to store values after reaction execution.
    var _out : event_t; // output _out:int;

    // A list of reactions
    procedure rxn_startup()
        returns (ret : event_t,
                 sP : integer)
    {
        // Reaction body
        sP = 0;

        // Since this reaction does not have
        // any antidependency, we can simply
        // set ret to NULL_EVENT.
        ret = NULL_EVENT;
    }

    procedure rxn__in()
        returns (ret : event_t,
                 sP : integer)
    {
        // Reaction body
        sP = s + _in._5;

        // This reaction does not return anything.
        // TODO: see if we can assert that this reaction
        // (or reactor B in general) can only return NULL.
        ret = NULL_EVENT;
    }

    init {
        NULL_EVENT = { -1, NULL, NULL, NULL_NULL, -1, false };
        __out__ = NULL_EVENT;
        _out = NULL_EVENT;
        _in = NULL_EVENT;
        s = -999; // Use this dummy value for now to denote init value.
        // s = 0; // Make unroll faster

        // Note; startup action initialization now in EventQ init{}.

        assume(__in__ == NULL_EVENT);
    }

    // TODO: find out how to detect the presence of 
    // multiple inputs. Reaction is triggered when
    // the presence of a trigger (or absence of which)
    // is known completely.
    next {
        // Check the value of __in__ and distribute
        // it to appropriate trigger, since we only
        // take one input event at a UCLID step.
        if (__in__ != NULL_EVENT) {
            if (__in__._4 == B_STARTUP) {
                _in' = __in__;
            }
            else {
                if (__in__._4 == B_IN) {
                    _in' = __in__;
                }
            }
            // ... matching other triggers ...
        }
        else {
            _in' = NULL_EVENT; // reset _in
        }

        // Match triggers with reactions
        if (_in._4 == B_STARTUP) {
            call (_out', s') = rxn_startup();
            __out__' = _out';
        }
        else {
            if (_in._4 == B_IN) {
                // Besides an out event, rxn__in() has the
                // side effect of modifying s, which is returned
                // here and put into s'.
                call (_out', s') = rxn__in();
                
                // TODO: push _out' into the outbound buffer
                // can be implemented using an array and 2 vars (hd & tl)

                // TODO: pop event from outbound buffer
                __out__' = _out';
            }
            else {
                // if () { ... other triggers ... }
                
                // If nothing matches, return a NULL_EVENT.
                __out__' = NULL_EVENT;
            }
        }
    }
}


/*****************
 * The main module
 *****************/
module main {
    type * = EventQ.*;

    // Channel between RTI and reactors
    var A_to_RTI : event_t;
    var B_to_RTI : event_t;
    var RTI_to_A : event_t;
    var RTI_to_B : event_t;

    var NULL_EVENT : event_t;

    // TODO: rename RTI and A's input/output var names to indicate direction
    instance rti : RTI(in_A : (A_to_RTI), out_A : (RTI_to_A),
                        in_B : (B_to_RTI), out_B : (RTI_to_B));
    instance a : Reactor_A(t : (rti.t), __in__ : (RTI_to_A), __out__ : (A_to_RTI));
    instance b : Reactor_B(t : (rti.t), __in__ : (RTI_to_B), __out__ : (B_to_RTI));

    init {
        NULL_EVENT = { -1, NULL, NULL, NULL_NULL, -1, false };
        A_to_RTI = NULL_EVENT;
        B_to_RTI = NULL_EVENT;
        RTI_to_A = NULL_EVENT;
        RTI_to_B = NULL_EVENT;

        // A convenient test case
        /*
        A_to_RTI = { 0, A, A, A_OUT, 10, true };
        */
    }

    next {
        next(rti); 
        next(a);
        next(b);
    }

    // A set of properties that are potentially helpful
    
    // Ensure RTI behaves correctly
    // property[LTL] A_receives_valid_event : G(a.__in__._3 == A || a.__in__._3 == NULL); 
    // property[LTL] B_receives_valid_event : G(b.__in__._3 == B || b.__in__._3 == NULL); 

    // Checking LF program w/ a focus on state variable.
    // Verify behavior of the reactor system
    property[LTL] s_is_eventually_1 : F(b.s == 1);
    // property[LTL] s_value_that_always_hold : G(b.s == -999 || b.s >= 0);
    // property[LTL] s_does_not_incr_until_input : W((b.s == 0 || b.s == -999), (b._in._4 == B_IN));

    control {
        // v = induction;
        v = bmc(10);
        check;
        print_results;
        v.print_cex(
                    rti.t,
                    rti.event_q.contents, 
                    rti.event_q.op,
                    rti.event_q.data,
                    rti.event_q.count,
                    rti.reaction_q.contents, 
                    rti.reaction_q.op,
                    rti.reaction_q.data,
                    rti.reaction_q.count,
                    rti.eq_op,
                    rti.eq_data,
                    rti.eq_out,
                    rti.rq_op,
                    rti.rq_data,
                    rti.rq_out,
                    rti.out_A,
                    rti.out_B,
                    rti.in_A,
                    rti.in_B,
                    a.__in__,
                    a.__out__,
                    b.__in__,
                    b.__out__,
                    b._in,
                    b.s
                    );
    }
}

