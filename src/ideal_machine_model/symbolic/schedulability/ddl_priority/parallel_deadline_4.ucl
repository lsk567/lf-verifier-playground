/**
 * Commit to one schedule, bound the execution time
 * and find out if the deadline is satisfiable.
 */

module A {
    output finish : integer;

    const exec_time : integer = 0;

    init {
        finish = -1;
    }

    next {
        finish' = 0 + exec_time;
    }
}

module B {
    input start : integer;
    output finish : integer;

    // const exec_time : integer = 3;
    const exec_time : integer;
    assume(exec_time == 3);

    init {
        finish = -1;
    }

    next {
        finish' = start + exec_time;
    }
}

module C {
    input start : integer;
    output finish : integer;

    const exec_time : integer;
    assume(exec_time == 1);

    const ddl : integer = 5; // assume the current timestamp is 0.

    var ddl_violation : boolean;

    define ddl_violated(t : integer) : boolean
    = if (t > ddl)
        then true else false;

    init {
        ddl_violation = false;
        finish = -1;
    }

    next {
        ddl_violation' = ddl_violated(start);
        finish' = start + exec_time;
    }
}

module D {
    input start : integer;
    output finish : integer;

    const exec_time : integer;
    assume(exec_time == 3);

    init {
        finish = -1;
    }

    next {
        finish' = start + exec_time;
    }
}

module E {
    input start : integer;
    output finish : integer;

    const exec_time : integer; // 3 + 3 > 5
    assume(exec_time == 3);

    const ddl : integer = 5; // assume the current timestamp is 0.

    var ddl_violation : boolean;

    define ddl_violated(t : integer) : boolean
    = if (t > ddl)
        then true else false;

    init {
        ddl_violation = false;
        finish = -1;
    }

    next {
        ddl_violation' = ddl_violated(start);
        finish' = start + exec_time;
    }
}

module main {
    type reactor_t = enum { RB, RC, RD, RE };
    type schedule_t = { reactor_t,
                         reactor_t, 
                         reactor_t, 
                         reactor_t };

    var current_physical_time : integer;

    var step : integer;
    var running : reactor_t;

    var schedule : schedule_t;

    define tupleGet(s : schedule_t, i : integer) : reactor_t
    = if (i == 1) then s._1 else
        (if (i == 2) then s._2 else
            (if (i == 3) then s._3 else
                (if (i == 4) then s._4 else s._4)));

    // Starting reactor can only be B or D
    assume(schedule._1 == RB || schedule._1 == RD);

    // B precedes C
    assume(!(exists (i : integer, j : integer) ::
            i >= 1 && i <= 4 &&
            j >= 1 && j <= 4 &&
            tupleGet(schedule, i) == RB &&
            tupleGet(schedule, j) == RC &&
            i > j));

    // D precedes E 
    assume(!(exists (i : integer, j : integer) ::
            i >= 1 && i <= 4 &&
            j >= 1 && j <= 4 &&
            tupleGet(schedule, i) == RD &&
            tupleGet(schedule, j) == RE &&
            i > j));

    // Cannot schedule the same reactor twice.
    assume(!(exists (i : integer, j : integer) ::
            i >= 1 && i <= 4 &&
            j >= 1 && j <= 4 &&
            i != j &&
            tupleGet(schedule, i) == tupleGet(schedule, j)));

    // instance a : A(finish : (current_physical_time));
    instance b : B(start : (current_physical_time), finish : (current_physical_time));
    instance c : C(start : (current_physical_time), finish : (current_physical_time));
    instance d : D(start : (current_physical_time), finish : (current_physical_time));
    instance e : E(start : (current_physical_time), finish : (current_physical_time));

    init {
        step = 0;
        current_physical_time = 0;
        
        /*
        running = RB;
        schedule[0] = RB;
        schedule[1] = RC;
        schedule[2] = RD;
        schedule[3] = RE;
        */
    }

    next {
        if (step <= 3) {
            case 
                (step == 0) : {
                    running' = schedule._1;
                }
                (step == 1) : {
                    running' = schedule._2;
                }
                (step == 2) : {
                    running' = schedule._3;
                }
                (step == 3) : {
                    running' = schedule._4;
                }
            esac

            case
                (running' == RB) : {
                    next(b);
                }
                (running' == RC) : {
                    next(c);
                }
                (running' == RD) : {
                    next(d);
                }
                (running' == RE) : {
                    next(e);
                }
            esac

            step' = step + 1;
        }
    }

    property[LTL] no_c_ddl_violation : G(step == 4 ==> c.ddl_violation == true);
    // property[LTL] test : (current_physical_time == -10);

    control {
        v = bmc(5);
        // v = induction;
        check;
        print_results;
        v.print_cex(
                    current_physical_time,
                    schedule,
                    step,
                    running,
                    b.start,
                    b.finish,
                    b.exec_time,
                    c.start,
                    c.finish,
                    c.exec_time,
                    c.ddl_violation,
                    d.start,
                    d.finish,
                    d.exec_time,
                    e.start,
                    e.finish,
                    e.exec_time,
                    e.ddl_violation
                    );
    }
}
